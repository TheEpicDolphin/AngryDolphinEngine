
#include "NavigationMesh.h"

#include <algorithm>
#include <Detour/Include/DetourNavMeshBuilder.h>

#include <iostream>

namespace pathfinding {
    inline uint8_t NextPow2(uint32_t value) {
        return std::ceil(std::log2(value));
    }

    /**
     * @brief Checks if two arrays of floats are approximately equal within an epsilon value.
     */
    inline bool IsApproximatelyEqual(const float* values1,
        uint32_t count1,
        const float* values2,
        uint32_t count2,
        float epsilon = 0.0001f) {
        if (count1 != count2) {
            return false;
        }

        for (std::size_t i = 0; i < count1; i++) {
            if (fabs(values1[i] - values2[i]) > epsilon) {
                return false;
            }
        }

        return true;
    }

    /**
     * @brief Checks if two arrays of uint16_t integers are exactly equal.
     */
    inline bool IsEqual(const uint16_t* values1, uint32_t count1, const uint16_t* values2, uint32_t count2) {
        if (count1 != count2) {
            return false;
        }

        for (std::size_t i = 0; i < count1; i++) {
            if (values1[i] != values2[i]) {
                return false;
            }
        }

        return true;
    }

    /**
     * @brief Finds the axis-aligned bounds of the given triangle
     */
    inline void calculateTriangleBounds(const float* v0,
        const float* v1,
        const float* v2,
        float* triAABBMin,
        float* triAABBMax) {
        triAABBMin[0] = std::min(std::min(v0[0], v1[0]), v2[0]);
        triAABBMin[1] = std::min(std::min(v0[1], v1[1]), v2[1]);
        triAABBMin[2] = std::min(std::min(v0[2], v1[2]), v2[2]);

        triAABBMax[0] = std::max(std::max(v0[0], v1[0]), v2[0]);
        triAABBMax[1] = std::max(std::max(v0[1], v1[1]), v2[1]);
        triAABBMax[2] = std::max(std::max(v0[2], v1[2]), v2[2]);
    }

    NavigationMesh::NavigationMesh(std::shared_ptr<NavigableSurfaceRegistry> navSurfaceRegistry) {
        tileHeightfield_ = nullptr;
        tileCompactHeightfield_ = nullptr;
        tileContourSet_ = nullptr;
        tilePolyMesh_ = nullptr;
        tilePolyMeshDetail_ = nullptr;
        recastNavMesh_ = nullptr;
        recastNavQuery_ = nullptr;
        polyPath_ = std::vector<dtPolyRef>(kMaxPolyPathSize);
        navSurfaceRegistry_ = navSurfaceRegistry;
    }

    NavigationMesh::~NavigationMesh() {
        // Deallocate Recast stuff.
        cleanup();

        if (recastNavMesh_) {
            dtFreeNavMesh(recastNavMesh_);
            recastNavMesh_ = nullptr;
        }

        if (recastNavQuery_) {
            dtFreeNavMeshQuery(recastNavQuery_);
            recastNavQuery_ = nullptr;
        }
    }

    void NavigationMesh::cleanup() {
        if (tileHeightfield_) {
            rcFreeHeightField(tileHeightfield_);
            tileHeightfield_ = nullptr;
        }

        if (tileCompactHeightfield_) {
            rcFreeCompactHeightfield(tileCompactHeightfield_);
            tileCompactHeightfield_ = nullptr;
        }

        if (tileContourSet_) {
            rcFreeContourSet(tileContourSet_);
            tileContourSet_ = nullptr;
        }

        if (tilePolyMesh_) {
            rcFreePolyMesh(tilePolyMesh_);
            tilePolyMesh_ = nullptr;
        }

        if (tilePolyMeshDetail_) {
            rcFreePolyMeshDetail(tilePolyMeshDetail_);
            tilePolyMeshDetail_ = nullptr;
        }
    }

    Result NavigationMesh::configure(
        float maxWalkableSlope,
        float agentRadius,
        float agentHeight,
        float agentMaxClimb,
        const float* targetSize,
        NavigationMeshConfigFeedback& feedback
    ) {
        // According to the author of Recast, a good value for voxel size is
        // 1/2 or 1/3 of the agent radius.
        float voxelSize = agentRadius / 3.0f;
        float voxelHeight = voxelSize / 2.0f;

        // TODO: Check for valid maxWalkableSlope, agentRadius, agentHeight, and 
        // agentMaxClimb values.
        
        // Navigation mesh size must be at least voxelSize along
        // local x and z axes and at least voxelHeight along y axis.
        size_[0] = std::max(voxelSize, targetSize[0]);
        size_[1] = std::max(voxelHeight, targetSize[1]);
        size_[2] = std::max(voxelSize, targetSize[2]);

        // For any given navigation mesh tile, the upper bound for the number of
        // triangles generated by Recast on a single floor can be estimated as follows:
        // 
        // 1. Calculate the maximum number of regions that can possibly be generated
        //    across a tile floor during the Recast watershed partioning process (more 
        //    regions --> more triangles).
        // 
        //    Region count is maximized when each region's area is as close to
        //    mergeRegionArea as possible. Given that each tile's area is tileSize^2,
        //    we have:
        //        regions per tile floor (upper bound) = tileSize^2 / mergeRegionArea
        // 
        // 2. Approximate each region as a circle, and find the maximum number of
        //    vertices generated by decimating it using the Ramer–Douglas–Peucker
        //    algorithm (used by Recast to simplify region outlines).
        //
        //    Solve for 'r' below:
        //        mergeRegionArea = pi * r^2;
        //    
        //    And after some geometry:
        //        Triangles per region (expected) = ceil(2 * pi / acos(1 - maxSimplificationError / r)) - 2
        //
        // 3. Multiply tris/region by regions/tile floor to get the upper bound for
        //    triangles per tile.
        //

        const int maxRegionsPerTileFloor = std::ceil(kTileSize * kTileSize / kMergeRegionArea);
        const int regionRadius = std::sqrt(kMergeRegionArea / pi);
        const int expectedTrisPerRegion = std::ceil(2 * pi / std::acos(1 - kMaxSimplificationError / regionRadius)) - 2;
        uint32_t maxTrisPerTileFloor = expectedTrisPerRegion * maxRegionsPerTileFloor;

        // There are only 22 bits available to be divided among identifying tiles
        // and identifying polys within those tiles.
        // Limitation of Recast. Allow enough bits for at least a single floor.
        const uint8_t tileBitsBudget = 22 - NextPow2(maxTrisPerTileFloor);
        const float tileSize = kTileSize * voxelSize;
        int xTiles = std::ceil(targetSize[0] / tileSize);
        int zTiles = std::ceil(targetSize[2] / tileSize);
        uint32_t maxTiles = xTiles * zTiles;
        const uint8_t tileBits = NextPow2(maxTiles);
        if (tileBits > tileBitsBudget) {
            // Use the entire tile bits budget:
            //     2 ^ tileBitsBudget = xTiles * zTiles;
            // 
            // Maintain z/x ratio:
            //     zTiles / xTiles = size[2] / size[0]
            // 
            // Solve for xTiles and zTiles...
            //

            xTiles = std::floor(std::sqrt((1 << tileBitsBudget) * (targetSize[0] / targetSize[2])));
            zTiles = std::floor(xTiles * (targetSize[2] / targetSize[0]));
            maxTiles = xTiles * zTiles;
            size_[0] = xTiles * tileSize;
            size_[2] = zTiles * tileSize;
        }

        xTilesRange[0] = - xTiles / 2;
        xTilesRange[1] = xTiles / 2;
        zTilesRange[0] = -zTiles / 2;
        zTilesRange[1] = zTiles / 2;
        
        uint32_t quadtreeDepth = std::max(NextPow2(xTiles), NextPow2(zTiles));
        chunkQuatree_.reset(tileSize, quadtreeDepth);

        const uint8_t polyBitsBudget = 22 - tileBits;
        int tileFloors = std::floor(targetSize[1] / agentHeight);
        uint32_t maxPolysPerTile = maxTrisPerTileFloor * tileFloors;
        const uint8_t polyBits = NextPow2(maxPolysPerTile);
        if (polyBits > polyBitsBudget) {
            // Use the entire poly bits budget and solve for tileFloors:
            //     2 ^ polyBitsBudget = tileFloors * maxTrisPerTileFloor
            //

            tileFloors = std::floor((1 << polyBitsBudget) / maxTrisPerTileFloor);
            maxPolysPerTile = tileFloors * maxTrisPerTileFloor;
            size_[1] = tileFloors * agentHeight;
        }

        maxWalkableSlope_ = maxWalkableSlope;
        agentRadius_ = agentRadius;
        agentHeight_ = agentHeight;
        agentMaxClimb_ = agentMaxClimb;
        // The author of recast recommends agent radius * 8 for the max edge length.
        maxEdgeLen_ = agentRadius * 8.0f;

        dtFreeNavMesh(recastNavMesh_);
        recastNavMesh_ = dtAllocNavMesh();
        if (!recastNavMesh_) {
            return Result::kErrorOutOfMemory;
        }

        // Set the navigation mesh parameters.
        dtNavMeshParams navMeshParams;
        navMeshParams.orig[0] = 0;
        navMeshParams.orig[1] = 0;
        navMeshParams.orig[2] = 0;
        navMeshParams.tileWidth = tileSize;
        navMeshParams.tileHeight = tileSize;
        navMeshParams.maxTiles = maxTiles;
        navMeshParams.maxPolys = maxPolysPerTile;

        dtStatus status;

        // Initialize the navigation mesh. This will contain the generated navigation mesh.
        status = recastNavMesh_->init(&navMeshParams);
        if (dtStatusFailed(status)) {
            return Result::kErrorUnexpected;
        }

        // Initialize the navigation mesh query. This is used for the actual pathfinding.
        recastNavQuery_ = dtAllocNavMeshQuery();
        status = recastNavQuery_->init(recastNavMesh_, 2048);
        if (dtStatusFailed(status)) {
            return Result::kErrorUnexpected;
        }

        // Init build configuration used for all tiles. These fields do not change after initialization.
        memset(&tileConfig_, 0, sizeof(tileConfig_));
        tileConfig_.cs = voxelSize;   // Voxel along x and z axis.
        tileConfig_.ch = voxelHeight; // Voxel height (y axis).
        tileConfig_.walkableSlopeAngle = maxWalkableSlope_;
        tileConfig_.walkableHeight = (int)ceilf(agentHeight_ / tileConfig_.ch);   // Voxel coordinates.
        tileConfig_.walkableClimb = (int)floorf(agentMaxClimb_ / tileConfig_.ch); // Voxel coordinates.
        tileConfig_.walkableRadius = (int)ceilf(agentRadius_ / tileConfig_.cs);   // Voxel coordinates.
        tileConfig_.maxEdgeLen = (int)(maxEdgeLen_ / tileConfig_.cs);             // Voxel coordinates.
        tileConfig_.maxSimplificationError = kMaxSimplificationError;
        tileConfig_.minRegionArea = kMinRegionArea;
        tileConfig_.mergeRegionArea = kMergeRegionArea;
        tileConfig_.maxVertsPerPoly = (int)kMaxVertsPerPoly;
        tileConfig_.tileSize = (int)kTileSize;
        tileConfig_.borderSize =
            tileConfig_.walkableRadius + 3; // The 3 adds a little extra buffer to the tile border size for better results.
        tileConfig_.width = tileConfig_.tileSize + tileConfig_.borderSize * 2;
        tileConfig_.height = tileConfig_.tileSize + tileConfig_.borderSize * 2;
        tileConfig_.detailSampleDist = kDetailSampleDistance < 0.9f ? 0 : tileConfig_.cs * kDetailSampleDistance;
        tileConfig_.detailSampleMaxError = tileConfig_.ch * kDetailSampleMaxError;

        return Result::kOk;
    }

    Result NavigationMesh::regenerateIfNeeded(NavigationMeshChangedChunk*& changedChunks, uint32_t& changedChunksCount) {
        // One navigation mesh regeneration at a time.
        const std::lock_guard<std::mutex> regenLock(navigationMeshRegenerationMutex_);

        displacedGroups_.insert(groupStates_.keys);
        std::vector<NavigableSurfaceGroupRef> groups = navSurfaceRegistry_->pinAllGroupsAndGet();
        for (auto groupsIter = groups.begin(); groupsIter != groups.end(); ++groupsIter) {
            NavigableSurfaceGroupRef groupRef = *groupsIter;
            navSurfaceRegistry_->getGroupRelativeTransform();
            if (IsApproximatelyEqual()) {
                displacedGroups_.erase(groupRef);
            } else {
                placedGroups_.push_back(groupRef);
            }
        }

        // Moved from
        for (auto displacedGroupsIter = displacedGroups_.begin();
            displacedGroupsIter != displacedGroups_.end();
            ++displacedGroupsIter) {
            const NavigableSurfaceGroupRef groupRef = *displacedGroupsIter;
            processDisplacedGroup(groupRef);
        }

        // Moved to
        for (auto placedGroupsIter = placedGroups_.begin();
            placedGroupsIter != placedGroups_.end();
            ++placedGroupsIter) {
            processPlacedGroup(*placedGroupsIter);
        }

        // Phase 1: Process registered geometry entities
        {
            const std::lock_guard<std::mutex> regLock(geometryEntityRegistrationMutex_);

            for (auto iter = enqueuedRegisteredGeometryEntities_.begin(); iter != enqueuedRegisteredGeometryEntities_.end();
                ++iter) {
                const NavigationMeshGeometryEntityHandle geometryEntityHandle = iter->first;
                NavigationMeshGeometryEntity& geometryEntity = iter->second;
                {
                    const std::unique_lock<std::shared_mutex> writeLock(geometryEntitiesMutex_);
                    geometryEntities_.insert({ geometryEntityHandle, geometryEntity });
                }

                {
                    const std::lock_guard<std::mutex> lock(geometryEntitySpatialChangeMutex_);
                    enqueuedSpatiallyChangedGeometryEntities_.insert(geometryEntityHandle);
                }
            }

            enqueuedRegisteredGeometryEntities_.clear();
        }

        // Phase 2: Process deregistered geometry entities
        {
            const std::lock_guard<std::mutex> deregLock(geometryEntityDeregistrationMutex_);

            for (auto iter = enqueuedDeregisteredGeometryEntities_.begin(); iter != enqueuedDeregisteredGeometryEntities_.end();
                ++iter) {
                const NavigationMeshGeometryEntityHandle handle = *iter;

                NavigationMeshGeometryEntity& geometryEntity = getGeometryEntitySafe(handle);
                std::vector<OrthtreeCellRef>& previouslyIntersectedTiles = geometryEntity.intersectionCandidateChunks;

                // For each tile previously intersected by this geometry entity, remove this geometry entity's
                // handle from its dictionary of intersections, and consider the tile "dirty".
                for (OrthtreeCellRef chunkCellRef : previouslyIntersectedTiles) {
                    NavigationMeshChunk* chunk;
                    if (chunkQuatree_.ObjectForCellRef(chunkCellRef, chunk)) {
                        chunk->intersectedGeometryEntityTris.erase(handle);

                        if (regenCandidateTiles_.find(chunkCellRef) == regenCandidateTiles_.end()) {
                            regenCandidateTiles_[chunkCellRef] = { false };
                        }
                    }
                }

                {
                    const std::unique_lock<std::shared_mutex> lock(geometryEntitiesMutex_);
                    // Delete geometry entity.
                    geometryEntities_.erase(handle);
                }
            }

            enqueuedDeregisteredGeometryEntities_.clear();
        }

        // Phase 3: Process geometry entity transform and/or geometry changes.
        {
            const std::lock_guard<std::mutex> lock(geometryEntitySpatialChangeMutex_);

            for (auto iter = enqueuedSpatiallyChangedGeometryEntities_.begin();
                iter != enqueuedSpatiallyChangedGeometryEntities_.end();
                ++iter) {
                processGeometryEntitySpatialChanges(*iter);
            }

            enqueuedSpatiallyChangedGeometryEntities_.clear();
        }

        // TODO: Phase 4: Process geometry entity flag/area changes.

        // Phase 5: Iterate candidate tiles and perform navigation mesh generation if necessary.
        const std::unique_lock<std::shared_mutex> navMeshWriteLock(navMeshQueryMutex_);
        changedChunksFromLastRegeneration_.clear();
        for (std::unordered_map<OrthtreeCellRef, RegenCandidateChunkData>::iterator regenCandidateChunkIter =
            regenCandidateChunks_.begin();
            regenCandidateChunkIter != regenCandidateChunks_.end();
            ++regenCandidateChunkIter) {
            const OrthtreeCellRef regenCandidateChunkCellRef = regenCandidateChunkIter->first;
            const bool isChunkNewlyCreated = regenCandidateChunkIter->second.isNewlyCreated;

            NavigationMeshChunk* regenCandidateChunk;
            int16_t chunkCoords[3];
            if (!chunkQuatree_.ObjectForCellRef(regenCandidateChunkCellRef, regenCandidateChunk) ||
                !chunkQuatree_.GetCoordinatesForCellRef(regenCandidateChunkCellRef, chunkCoords)) {
                continue;
            }

            if (!regenCandidateChunk->intersectedGeometryEntityTris.empty()) {
                // This tile potentially intersects with geometry entities.
                int navmeshDataSize = 0;
                unsigned char* navmeshData;
                ChunkNavMeshGenStatus genStatus =
                    buildNavigationMeshAt(chunkCoords[0], chunkCoords[1], chunkCoords[2], regenCandidateChunk->intersectedGeometryEntityTris, navmeshData, navmeshDataSize);

                switch (genStatus) {
                case ChunkNavMeshGenStatus::Success: {
                    dtStatus status;
                    {
                        const std::unique_lock<std::shared_mutex> writeLock(navMeshTileMutex_);
                        // Clear old navigation mesh for this tile.
                        clearNavigationMeshForChunk(regenCandidateChunk);
                        // Add newly built navigation mesh for this tile.
                        status = recastNavMesh_->addTile(navmeshData, navmeshDataSize, DT_TILE_FREE_DATA, 0, &regenCandidateChunk->tileRef);
                    }
                    if (dtStatusFailed(status)) {
                        // Free the navmesh data because we failed to add the tile's navigation mesh.
                        dtFree(navmeshData);
                    }
                    else {
                        // The tile's navigation mesh was successfully incorporated into the main navigation mesh.
                        //
                        // Write this tile's generated navigation mesh data to changedTilesDataBuffer, if any space is available.
                        NavigationMeshChangedChunk changedChunk;
                        changedChunk.changeType = isChunkNewlyCreated ? (unsigned char)1 : (unsigned char)2;
                        changedChunk.chunkRef = regenCandidateTileCellRef;
                        changedChunksFromLastRegeneration_.push_back(changedChunk);
                    }
                } break;
                case ChunkNavMeshGenStatus::NoGeneration: {
                    // No navigation mesh was generated for this tile. It is a false positive.
                    if (isChunkNewlyCreated) {
                        // If tile was newly created, delete it.
                        chunkQuatree_.RemoveCell(regenCandidateTileCellRef);
                    }
                } break;
                default:
                    // no-op. There was straight up an issue with this tile's navmesh generation.
                    break;
                }
            }
            else {
                // This tile has no geometry intersecting it. Delete it.
                // TODO: Assert that isTileNewlyCreated is false.
                NavigationMeshChangedChunk changedChunk;
                changedChunk.changeType = (unsigned char)3;
                changedChunk.chunkRef = regenCandidateTileCellRef;
                changedChunksFromLastRegeneration_.push_back(changedChunk);

                {
                    const std::unique_lock<std::shared_mutex> writeLock(navMeshTileMutex_);
                    clearNavigationMeshForChunk(regenCandidateChunk);
                }
                chunkQuatree_.RemoveCell(regenCandidateTileCellRef);
            }
        }

        regenCandidateTiles_.clear();

        // Set the tiles that were changed during this regeneration.
        changedChunks = changedChunksFromLastRegeneration_.data();
        changedChunksCount = changedChunksFromLastRegeneration_.size();

        return Result::kOk;
    }

    void NavigationMesh::processDisplacedGroup(NavigableSurfaceGroupRef groupRef) {
        auto foundGroupStateIter = groupStates_.find(groupRef);
        NavigableSurfaceGroupState& groupState = foundGroupStateIter->second;
        // Find chunks that were previously intersected by this group.
        for (NavigationMeshChunkRef chunkRef : groupState.potentiallyIntersectingChunks) {
            regenCandidateChunks_[chunkRef] = { false };
        }

        // Clear previously intersected chunks. We will calculate new ones.
        groupState.potentiallyIntersectingChunks.clear();
    }

    void NavigationMesh::processPlacedGroup(NavigableSurfaceGroupRef groupRef) {
        NavigationMeshGeometryEntity& geometryEntity = getGeometryEntitySafe(handle);

        // Transform geometry verts to navigation mesh local space using new transform and/or new geometry.
        geometryEntity.transformedGeometryVertices.clear();
        for (std::size_t i = 0; i < geometryEntity.geometry.vertices.size(); i += 3) {
            float vertex[3] = { geometryEntity.geometry.vertices[i],
                               geometryEntity.geometry.vertices[i + 1],
                               geometryEntity.geometry.vertices[i + 2] };
            float transformedVertex[3];
            TransformPoint(geometryEntity.transform, vertex, transformedVertex);
            geometryEntity.transformedGeometryVertices.push_back(transformedVertex[0]); // push_back x
            geometryEntity.transformedGeometryVertices.push_back(transformedVertex[1]); // push_back y
            geometryEntity.transformedGeometryVertices.push_back(transformedVertex[2]); // push_back z
        }

        // Find tiles affected by the geometry entity after its geometry is transformed.
        for (std::size_t triIndex = 0; triIndex < geometryEntity.geometry.triangles.size(); triIndex += 3) {
            const uint16_t v0i = geometryEntity.geometry.triangles[triIndex];
            const uint16_t v1i = geometryEntity.geometry.triangles[triIndex + 1];
            const uint16_t v2i = geometryEntity.geometry.triangles[triIndex + 2];

            const float* v0 = &geometryEntity.transformedGeometryVertices[3 * v0i];
            const float* v1 = &geometryEntity.transformedGeometryVertices[3 * v1i];
            const float* v2 = &geometryEntity.transformedGeometryVertices[3 * v2i];

            // Calculate AABB for triangle.
            float triAABBMin[3];
            float triAABBMax[3];
            calculateTriangleBounds(v0, v1, v2, triAABBMin, triAABBMax);

            // Expand triangle AABB by the tile border.
            // It is faster to expand the triangle AABB by the border size and check for intersections
            // with surrounding tiles than it is to expand each tile AABB by the border size and check if
            // it intersects this triangle.
            //const float borderSizeXZ = tileConfig_.borderSize * tileConfig_.cs;
            //const float borderSizeY = tileConfig_.borderSize * tileConfig_.ch;
            const float borderSize = tileConfig_.borderSize * tileConfig_.cs;
            triAABBMin[0] -= borderSize;
            triAABBMin[1] -= borderSize;
            triAABBMin[2] -= borderSize;
            triAABBMax[0] += borderSize;
            triAABBMax[1] += borderSize;
            triAABBMax[2] += borderSize;

            int16_t minChunkCoords[3];
            chunkQuatree_.GetCellCoordinatesForPosition(triAABBMin, minChunkCoords);
            int16_t maxChunkCoords[3];
            chunkQuatree_.GetCellCoordinatesForPosition(triAABBMax, maxChunkCoords);
            // This may produce some false positives for tile-triangle intersections, but that is ok because
            // the false positives are later filtered out internally by Recast during the rasterization process.
            for (int16_t x = minChunkCoords[0]; x <= maxChunkCoords[0]; x++) {
                for (int16_t z = minChunkCoords[2]; z <= maxChunkCoords[2]; z++) {
                    int16_t chunkCoords[2] = { x, z };
                    OrthtreeCellRef chunkCellRef = chunkQuatree_.GetCellRefForCoordinates(chunkCoords);
                    if (chunkCellRef < 0) {
                        // Create a new tile.
                        chunkCellRef = chunkQuatree_.AddCellAt(chunkCoords, { 0, {} });
                        regenCandidateChunks_[chunkCellRef] = { true };
                    }
                    else {
                        if (regenCandidateChunks_.find(chunkCellRef) == regenCandidateChunks_.end()) {
                            regenCandidateChunks_[chunkCellRef] = { false };
                        }
                    }

                    NavigationMeshChunk* chunk;
                    if (chunkQuatree_.ObjectForCellRef(chunkCellRef, chunk)) {
                        auto geometryEntityTrisIter = chunk->intersectedGeometryEntityTris.find(handle);
                        if (geometryEntityTrisIter != chunk->intersectedGeometryEntityTris.end()) {
                            geometryEntityTrisIter->second.push_back(v0i);
                            geometryEntityTrisIter->second.push_back(v1i);
                            geometryEntityTrisIter->second.push_back(v2i);
                        }
                        else {
                            chunk->intersectedGeometryEntityTris[handle] = { v0i, v1i, v2i };
                        }

                        geometryEntity.intersectionCandidateChunks.push_back(chunkCellRef);
                    }
                }
            }
        }
    }

    Result NavigationMesh::getNavigationMeshDataForChunk(
        int16_t tx,
        int16_t ty,
        int16_t tz,
        float* origin,
        uint16_t*& triangles,
        uint32_t& trianglesCount,
        float*& vertices,
        uint32_t& verticesCount) {
        chunkNavigationMeshTriangles_.clear();
        chunkNavigationMeshVertices_.clear();

        //const float chunkSizeXZ = tileConfig_.tileSize * tileConfig_.cs;
        //const float chunkSizeY = tileConfig_.tileSize * tileConfig_.ch;
        const float chunkSize = tileConfig_.tileSize * tileConfig_.cs;
        origin[0] = tx * chunkSize;
        origin[1] = ty * chunkSize;
        origin[2] = tz * chunkSize;

        const std::shared_lock<std::shared_mutex> readLock(navMeshTileMutex_);
        const dtMeshTile* meshTile = recastNavMesh_->getTileAt(tx, tz, ty);
        if (!meshTile) {
            triangles = nullptr;
            trianglesCount = 0;
            vertices = nullptr;
            verticesCount = 0;
            return Result::kOk;
        }

        trianglesCount = (kMaxVertsPerPoly - 2) * meshTile->header->polyCount;
        verticesCount = meshTile->header->vertCount;
        chunkNavigationMeshTriangles_.resize(3 * trianglesCount);
        chunkNavigationMeshVertices_.resize(3 * verticesCount);
        triangles = chunkNavigationMeshTriangles_.data();
        vertices = chunkNavigationMeshVertices_.data();

        const int nvp = tileConfig_.maxVertsPerPoly;
        for (int i = 0; i < meshTile->header->polyCount; ++i) {
            const dtPoly poly = meshTile->polys[i];
            uint16_t vi[3];

            // We perform a simple triangulation of the polygon if the
            // vertex count exceeds 3.
            for (int j = 2; j < nvp; ++j) {
                if (poly.verts[j] == RC_MESH_NULL_IDX) {
                    break;
                }

                vi[0] = poly.verts[0];
                vi[1] = poly.verts[j - 1];
                vi[2] = poly.verts[j];
                for (int k = 0; k < 3; ++k) {
                    chunkNavigationMeshTriangles_[3 * ((nvp - 2) * i + (j - 2)) + k] = vi[k];
                }
            }
        }

        // Calculate vertex positions relative to the tile origin.
        for (uint32_t i = 0; i < chunkNavigationMeshVertices_.size(); i += 3) {
            for (uint32_t j = 0; j < 3; ++j) {
                chunkNavigationMeshVertices_[i + j] = meshTile->verts[i + j] - origin[j];
            }
        }

        return Result::kOk;
    }

    void NavigationMesh::clearNavigationMeshForChunk(NavigationMeshChunk* chunk) {
        recastNavMesh_->removeTile(chunk->tileRef, 0, 0);
    }

    NavigationMesh::ChunkNavMeshGenStatus NavigationMesh::buildNavigationMeshAt(
        int16_t tx,
        int16_t ty,
        int16_t tz,
        const std::unordered_map<NavigationMeshGeometryEntityHandle, std::vector<uint16_t>>& intersectedGeometryEntityTris,
        unsigned char*& navMeshData,
        int& navMeshDataSize) {
        // Find axis aligned bounding box of the tile.
        //const float chunkSizeXZ = tileConfig_.tileSize * tileConfig_.cs;
        //const float chunkSizeY = tileConfig_.tileSize * tileConfig_.ch;
        const float chunkSize = tileConfig_.tileSize * tileConfig_.cs;
        const float minX = tx * chunkSize;
        const float minY = ty * chunkSize;
        const float minZ = tz * chunkSize;

        float chunkAABBMin[3] = { minX, minY, minZ };
        float chunkAABBMax[3] = { minX + chunkSize, minY + chunkSize, minZ + chunkSize };
        rcVcopy(tileConfig_.bmin, chunkAABBMin);
        rcVcopy(tileConfig_.bmax, chunkAABBMax);

        // Expand this box along xz plane by borderSize * cellSize to account for geometry near
        // the edges of the tile.
        //const float borderSizeXZ = tileConfig_.borderSize * tileConfig_.cs;
        //const float borderSizeY = tileConfig_.borderSize * tileConfig_.ch;
        const float borderSize = tileConfig_.borderSize * tileConfig_.cs;
        tileConfig_.bmin[0] -= borderSize;
        tileConfig_.bmin[1] -= borderSize;
        tileConfig_.bmin[2] -= borderSize;
        tileConfig_.bmax[0] += borderSize;
        tileConfig_.bmin[1] += borderSize;
        tileConfig_.bmax[2] += borderSize;

        // Clean up objects used in the intermediate tile navmesh generation pipeline.
        cleanup();

        // Allocate voxel heightfield where we rasterize our input data to.
        tileHeightfield_ = rcAllocHeightfield();
        if (!tileHeightfield_) {
            return ChunkNavMeshGenStatus::AllocationFailure;
        }
        if (!rcCreateHeightfield(&recastContext_,
            *tileHeightfield_,
            tileConfig_.width,
            tileConfig_.height,
            tileConfig_.bmin,
            tileConfig_.bmax,
            tileConfig_.cs,
            tileConfig_.ch)) {
            return ChunkNavMeshGenStatus::BuildFailure;
        }

        // Rasterize all intersecting geometry entities onto the tile.
        for (auto& intersectedGeometryEntityTris : intersectedGeometryEntityTris) {
            const NavigationMeshGeometryEntityHandle handle = intersectedGeometryEntityTris.first;
            const NavigationMeshGeometryEntity& geometryEntity = geometryEntities_[handle];
            const std::vector<uint16_t>& intersectedTriangles = intersectedGeometryEntityTris.second;

            // Not all of these vertices will be used. Only those indexed by intersectedTriangles will be used by Recast.
            const float* verts = geometryEntity.transformedGeometryVertices.data();
            const std::size_t nverts = geometryEntity.transformedGeometryVertices.size() / 3;
            const uint16_t* ctris = intersectedTriangles.data();
            const std::size_t nctris = intersectedTriangles.size() / 3;

            unsigned char* triareas = new unsigned char[nctris];
            memset(triareas, RC_WALKABLE_AREA, nctris * sizeof(unsigned char));

            // memset(triareas, 0, nctris * sizeof(unsigned char));
            // rcMarkWalkableTriangles(&recastContext_, tileConfig_.walkableSlopeAngle,
            //    verts, nverts, ctris, nctris, triareas);

            // TODO: Set area ids of triangles for this entity
            bool success = rcRasterizeTriangles(&recastContext_,
                verts,    // Vertices
                nverts,   // Number of vertices
                ctris,    // Triangle indices
                triareas, // Area id corresponding to these triangles. TODO: Set this field to
                          // the area id of this geometry entity.
                nctris,   // Number of triangles
                *tileHeightfield_,        // Heightfield
                tileConfig_.walkableClimb // Walkable climb
            );

            delete[] triareas;

            if (!success) {
                return ChunkNavMeshGenStatus::RasterizationFailure;
            }
        }

        // Filter out unwanted overhangs caused by Recast's conservative rasterization.
        rcFilterLowHangingWalkableObstacles(&recastContext_, tileConfig_.walkableClimb, *tileHeightfield_);

        // Filter out spans where the character cannot stand.
        rcFilterLedgeSpans(&recastContext_, tileConfig_.walkableHeight, tileConfig_.walkableClimb, *tileHeightfield_);
        rcFilterWalkableLowHeightSpans(&recastContext_, tileConfig_.walkableHeight, *tileHeightfield_);

        // Compact the heightfield so that it is faster to handle from now on.
        // This will result more cache coherent data as well as the neighbours
        // between walkable cells will be calculated.
        tileCompactHeightfield_ = rcAllocCompactHeightfield();
        if (!tileCompactHeightfield_) {
            return ChunkNavMeshGenStatus::AllocationFailure;
        }
        if (!rcBuildCompactHeightfield(&recastContext_,
            tileConfig_.walkableHeight,
            tileConfig_.walkableClimb,
            *tileHeightfield_,
            *tileCompactHeightfield_)) {
            return ChunkNavMeshGenStatus::BuildFailure;
        }

        // Erode the walkable area by agent radius.
        /*
        if (!rcErodeWalkableArea(&recastContext_, tileConfig_.walkableRadius, *tileCompactHeightfield_)) {
            recastContext_.log(RC_LOG_ERROR, "buildNavigation: Failed to erode.");
            return ChunkNavMeshGenStatus::ErosionFailure;
        }*/

        // Prepare for Watershed region partitioning by calculating distance field along the walkable surface.
        if (!rcBuildDistanceField(&recastContext_, *tileCompactHeightfield_)) {
            return ChunkNavMeshGenStatus::BuildFailure;
        }

        // Partition the walkable surface into simple regions without holes.
        if (!rcBuildRegions(&recastContext_,
            *tileCompactHeightfield_,
            tileConfig_.borderSize,
            tileConfig_.minRegionArea,
            tileConfig_.mergeRegionArea)) {
            return ChunkNavMeshGenStatus::BuildFailure;
        }

        // Create contours.
        tileContourSet_ = rcAllocContourSet();
        if (!tileContourSet_) {
            return ChunkNavMeshGenStatus::AllocationFailure;
        }
        if (!rcBuildContours(&recastContext_,
            *tileCompactHeightfield_,
            tileConfig_.maxSimplificationError,
            tileConfig_.maxEdgeLen,
            *tileContourSet_)) {
            return ChunkNavMeshGenStatus::BuildFailure;
        }

        if (tileContourSet_->nconts == 0) {
            // Zero contours were produce. Return early because no navmesh will be generated for this tile.
            return ChunkNavMeshGenStatus::NoGeneration;
        }

        // Build polygon navmesh from the contours.
        tilePolyMesh_ = rcAllocPolyMesh();
        if (!tilePolyMesh_) {
            return ChunkNavMeshGenStatus::AllocationFailure;
        }

        if (!rcBuildPolyMesh(&recastContext_, *tileContourSet_, tileConfig_.maxVertsPerPoly, *tilePolyMesh_)) {
            return ChunkNavMeshGenStatus::BuildFailure;
        }

        // Build detail mesh.
        tilePolyMeshDetail_ = rcAllocPolyMeshDetail();
        if (!tilePolyMeshDetail_) {
            return ChunkNavMeshGenStatus::AllocationFailure;
        }
        if (!rcBuildPolyMeshDetail(&recastContext_,
            *tilePolyMesh_,
            *tileCompactHeightfield_,
            tileConfig_.detailSampleDist,
            tileConfig_.detailSampleMaxError,
            *tilePolyMeshDetail_)) {
            return ChunkNavMeshGenStatus::BuildFailure;
        }

        // Set poly flags.
        for (int i = 0; i < tilePolyMesh_->npolys; ++i) {
            tilePolyMesh_->flags[i] = 0xFFFF;
        }

        // Build the navmesh for this tile.
        dtNavMeshCreateParams params;
        memset(&params, 0, sizeof(params));
        params.verts = tilePolyMesh_->verts;
        params.vertCount = tilePolyMesh_->nverts;
        params.polys = tilePolyMesh_->polys;
        params.polyAreas = tilePolyMesh_->areas;
        params.polyFlags = tilePolyMesh_->flags;
        params.polyCount = tilePolyMesh_->npolys;
        params.nvp = tilePolyMesh_->nvp;
        params.detailMeshes = tilePolyMeshDetail_->meshes;
        params.detailVerts = tilePolyMeshDetail_->verts;
        params.detailVertsCount = tilePolyMeshDetail_->nverts;
        params.detailTris = tilePolyMeshDetail_->tris;
        params.detailTriCount = tilePolyMeshDetail_->ntris;
        // TODO: Off mesh connection parameters.
        params.walkableHeight = agentHeight_;
        params.walkableRadius = agentRadius_;
        params.walkableClimb = agentMaxClimb_;
        params.tileX = tx;
        params.tileY = tz;
        params.tileLayer = ty;
        rcVcopy(params.bmin, tilePolyMesh_->bmin);
        rcVcopy(params.bmax, tilePolyMesh_->bmax);
        params.cs = tileConfig_.cs;
        params.ch = tileConfig_.ch;
        params.buildBvTree = true;

        if (!dtCreateNavMeshData(&params, &navMeshData, &navMeshDataSize)) {
            return ChunkNavMeshGenStatus::BuildFailure;
        }

        return ChunkNavMeshGenStatus::Success;
    }

    Result NavigationMesh::findPath(const float* fromPoint,
        const float* toPoint,
        uint32_t maxPathPointsCount,
        float* pathPoints,
        uint32_t& foundPathPointsCount) {
        float inputPoint[3];
        OrthtreeCellRef cellContainingInputPoint;
        dtPolyRef closestPoly;
        float closestPolyPoint[3];
        std::function<float(OrthtreeCellRef, NavigationMeshChunk&, float)> actionBlock =
            [this, &inputPoint, &cellContainingInputPoint, &closestPoly, &closestPolyPoint](OrthtreeCellRef cellRef,
                NavigationMeshChunk& chunk,
                float closestPolyPointSqrDist) {
                    const dtMeshTile* meshTile = recastNavMesh_->getTileByRef(chunk.tileRef);
                    const dtPolyRef polyRefBase = recastNavMesh_->getPolyRefBase(meshTile);
                    const int polyCount = meshTile->header->polyCount;
                    for (int polyIdx = 0; polyIdx < polyCount; ++polyIdx) {
                        const dtPolyRef candidatePolyRef = polyRefBase + polyIdx;
                        float closestPointOnPoly[3];
                        if (cellContainingInputPoint == cellRef) {
                            bool isInputPointOverPoly;
                            recastNavQuery_->closestPointOnPoly(candidatePolyRef, inputPoint, closestPointOnPoly, &isInputPointOverPoly);
                        }
                        else {
                            // If the examined cell does not contain the input point, we can perform
                            // the less expensive 'closestPointOnPolyBoundary' function.
                            recastNavQuery_->closestPointOnPolyBoundary(candidatePolyRef, inputPoint, closestPointOnPoly);
                        }

                        const float sqrDist = rcVdistSqr(inputPoint, closestPointOnPoly);
                        if (sqrDist < closestPolyPointSqrDist) {
                            closestPolyPointSqrDist = sqrDist;
                            closestPoly = candidatePolyRef;
                            rcVcopy(closestPolyPoint, closestPointOnPoly);
                        }
                    }
                    return closestPolyPointSqrDist;
        };

        const std::shared_lock<std::shared_mutex> navMeshReadLock(navMeshQueryMutex_);
        int16_t chunkCoords[3];

        // Get closest point on the navigation mesh to 'fromPoint'.
        rcVcopy(inputPoint, fromPoint);
        chunkQuatree_.GetCellCoordinatesForPosition(inputPoint, chunkCoords);
        cellContainingInputPoint = chunkQuatree_.GetCellRefForCoordinates(chunkCoords);
        closestPoly = 0;
        chunkQuatree_.QueryNearestNeighbourCells(fromPoint, actionBlock);
        if (!closestPoly) {
            foundPathPointsCount = 0;
            return Result::kOk;
        }
        const dtPolyRef closestStartPoly = closestPoly;
        float closestStartPoint[3];
        rcVcopy(closestStartPoint, closestPolyPoint);

        // Get closest point on the navigation mesh to 'toPoint'.
        rcVcopy(inputPoint, toPoint);
        chunkQuatree_.GetCellCoordinatesForPosition(inputPoint, chunkCoords);
        cellContainingInputPoint = chunkQuatree_.GetCellRefForCoordinates(chunkCoords);
        closestPoly = 0;
        chunkQuatree_.QueryNearestNeighbourCells(toPoint, actionBlock);
        if (!closestPoly) {
            foundPathPointsCount = 0;
            return Result::kOk;
        }
        const dtPolyRef closestEndPoly = closestPoly;
        float closestEndPoint[3];
        rcVcopy(closestEndPoint, closestPolyPoint);

        dtQueryFilter queryFilter;
        queryFilter.setIncludeFlags(0xFFFF);
        queryFilter.setExcludeFlags(0);
        queryFilter.setAreaCost(RC_WALKABLE_AREA, 1.0f);

        // Calculate the path of triangles leading from 'fromPoint' to 'toPoint'.
        int polyPathCount;
        dtStatus status = recastNavQuery_->findPath(closestStartPoly,
            closestEndPoly,
            closestStartPoint,
            closestEndPoint,
            &queryFilter,
            polyPath_.data(),
            &polyPathCount,
            std::min(kMaxPolyPathSize, maxPathPointsCount));
        if (dtStatusFailed(status)) {
            foundPathPointsCount = 0;
            return Result::kOk;
        }

        const bool isPartialPath = dtStatusDetail(status, DT_PARTIAL_RESULT);

        // We don't care about these.
        unsigned char* straightPathFlags = nullptr;
        dtPolyRef* straightPathPolyRefs = nullptr;

        // Calculate the 'string pulled' path of points leading from 'fromPoint' to 'toPoint'.
        int straightPathCount;
        recastNavQuery_->findStraightPath(closestStartPoint,
            closestEndPoint,
            polyPath_.data(),
            polyPathCount,
            pathPoints,
            straightPathFlags,
            straightPathPolyRefs,
            &straightPathCount,
            maxPathPointsCount,
            DT_STRAIGHTPATH_ALL_CROSSINGS);

        // When the end point is not reachable from the starting point, Detour makes a "best guess" and
        // returns a partial path that leads to a location near the end point. Sometimes, Detour erroneously
        // produces a partial path in which the last point coincides exactly with the target end point and
        // is impossible to walk to (e.g., requires the agent to walk vertically or off-mesh). We correct
        // this by simply removing the last path point whenever this occurs.
        if (isPartialPath && straightPathCount > 0) {
            const float* lastPathPoint = pathPoints + 3 * (straightPathCount - 1);
            // Below, we ensure that the square distance threshold scales with the
            // cell size/height of the navigation mesh.
            const double refDist = std::min(tileConfig_.cs, tileConfig_.ch);
            const double threshold = refDist * refDist * 1e-4;
            if (rcVdistSqr(lastPathPoint, closestEndPoint) < threshold) {
                // Remove last path point.
                straightPathCount -= 1;
            }
        }

        foundPathPointsCount = straightPathCount;
        return Result::kOk;
    }

} // namespace pathfinding

